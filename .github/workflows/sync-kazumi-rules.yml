name: åŒæ­¥ KazumiRules è§„åˆ™

on:
  # æ¯å¤©å‡Œæ™¨ 2 ç‚¹è‡ªåŠ¨åŒæ­¥
  schedule:
    - cron: '0 2 * * *'
  # æ‰‹åŠ¨è§¦å‘
  workflow_dispatch:
    inputs:
      sync_strategy:
        description: 'åŒæ­¥ç­–ç•¥'
        required: true
        default: 'smart'
        type: choice
        options:
          - 'full'      # å®Œå…¨åŒæ­¥ï¼Œè¦†ç›–æ‰€æœ‰æ–‡ä»¶
          - 'smart'     # æ™ºèƒ½åŒæ­¥ï¼ŒåŸºäºç‰ˆæœ¬å’Œæ—¶é—´æˆ³
          - 'incremental' # å¢é‡åŒæ­¥ï¼Œåªæ·»åŠ æ–°è§„åˆ™
          - 'selective' # é€‰æ‹©æ€§åŒæ­¥ï¼ŒåŸºäºé…ç½®åˆ—è¡¨
      selected_rules:
        description: 'é€‰æ‹©æ€§åŒæ­¥çš„è§„åˆ™åˆ—è¡¨ (é€—å·åˆ†éš”ï¼Œä»…å½“ç­–ç•¥ä¸º selective æ—¶æœ‰æ•ˆ)'
        required: false
        default: ''
      force_update:
        description: 'å¼ºåˆ¶æ›´æ–°æ‰€æœ‰è§„åˆ™'
        required: false
        default: false
        type: boolean

permissions:
  contents: write

jobs:
  sync-rules:
    runs-on: ubuntu-latest
    
    steps:
    - name: æ£€å‡ºä»£ç 
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: è®¾ç½® Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: åˆ›å»ºåŒæ­¥è„šæœ¬
      run: |
        cat > sync_kazumi_rules.js << 'EOF'
        const fs = require('fs');
        const path = require('path');
        const https = require('https');
        
        // é…ç½®
        const CONFIG = {
          KAZUMI_REPO: 'https://raw.githubusercontent.com/Predidit/KazumiRules/main',
          LOCAL_RULES_DIR: './rules',
          LOCAL_INDEX_FILE: './index.json',
          BACKUP_DIR: './backup',
          MAX_CONCURRENT: 5,
          RETRY_COUNT: 3,
          SYNC_STRATEGY: process.env.SYNC_STRATEGY || 'smart',
          SELECTED_RULES: process.env.SELECTED_RULES ? process.env.SELECTED_RULES.split(',').map(s => s.trim()) : [],
          FORCE_UPDATE: process.env.FORCE_UPDATE === 'true'
        };
        
        // ç»Ÿè®¡ä¿¡æ¯
        const stats = {
          total: 0,
          downloaded: 0,
          updated: 0,
          added: 0,
          skipped: 0,
          failed: 0,
          errors: []
        };
        
        // HTTP è¯·æ±‚å°è£…
        function httpsGet(url) {
          return new Promise((resolve, reject) => {
            const req = https.get(url, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                if (res.statusCode === 200) {
                  resolve(data);
                } else {
                  reject(new Error(`HTTP ${res.statusCode}: ${url}`));
                }
              });
            });
            req.on('error', reject);
            req.setTimeout(30000, () => {
              req.destroy();
              reject(new Error(`Timeout: ${url}`));
            });
          });
        }
        
        // é‡è¯•æœºåˆ¶
        async function withRetry(fn, retries = CONFIG.RETRY_COUNT) {
          for (let i = 0; i < retries; i++) {
            try {
              return await fn();
            } catch (error) {
              if (i === retries - 1) throw error;
              console.log(`é‡è¯• ${i + 1}/${retries}: ${error.message}`);
              await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
            }
          }
        }
        
        // è·å– KazumiRules çš„ index.json
        async function fetchKazumiIndex() {
          console.log('ğŸ“¥ è·å– KazumiRules index.json...');
          const url = `${CONFIG.KAZUMI_REPO}/index.json`;
          const data = await withRetry(() => httpsGet(url));
          return JSON.parse(data);
        }
        
        // è·å–æœ¬åœ° index.json
        function getLocalIndex() {
          if (!fs.existsSync(CONFIG.LOCAL_INDEX_FILE)) {
            return [];
          }
          try {
            return JSON.parse(fs.readFileSync(CONFIG.LOCAL_INDEX_FILE, 'utf8'));
          } catch (error) {
            console.log('âš ï¸  æœ¬åœ° index.json è§£æå¤±è´¥ï¼Œå°†åˆ›å»ºæ–°çš„');
            return [];
          }
        }
        
        // æ£€æŸ¥è§„åˆ™æ˜¯å¦éœ€è¦æ›´æ–°
        function shouldUpdateRule(remoteRule, localRule) {
          if (CONFIG.FORCE_UPDATE) return true;
          if (!localRule) return true;
          
          switch (CONFIG.SYNC_STRATEGY) {
            case 'full':
              return true;
            case 'smart':
              // æ¯”è¾ƒç‰ˆæœ¬å’Œæ›´æ–°æ—¶é—´
              if (remoteRule.version !== localRule.version) return true;
              if (remoteRule.lastUpdate > localRule.lastUpdate) return true;
              return false;
            case 'incremental':
              return !localRule;
            case 'selective':
              return CONFIG.SELECTED_RULES.includes(remoteRule.name) && 
                     (remoteRule.version !== localRule.version || remoteRule.lastUpdate > localRule.lastUpdate);
            default:
              return false;
          }
        }
        
        // ä¸‹è½½è§„åˆ™æ–‡ä»¶
        async function downloadRule(ruleName) {
          const url = `${CONFIG.KAZUMI_REPO}/${ruleName}.json`;
          console.log(`  ğŸ“¥ ä¸‹è½½ ${ruleName}.json...`);
          
          try {
            const data = await withRetry(() => httpsGet(url));
            const ruleData = JSON.parse(data);
            
            // éªŒè¯è§„åˆ™æ–‡ä»¶æ ¼å¼
            if (!ruleData.name || !ruleData.version) {
              throw new Error(`è§„åˆ™æ–‡ä»¶æ ¼å¼æ— æ•ˆ: ${ruleName}`);
            }
            
            return ruleData;
          } catch (error) {
            stats.errors.push(`ä¸‹è½½ ${ruleName} å¤±è´¥: ${error.message}`);
            throw error;
          }
        }
        
        // ä¿å­˜è§„åˆ™æ–‡ä»¶
        function saveRule(ruleData) {
          const filePath = path.join(CONFIG.LOCAL_RULES_DIR, `${ruleData.name}.json`);
          
          // å¤‡ä»½ç°æœ‰æ–‡ä»¶
          if (fs.existsSync(filePath) && !fs.existsSync(CONFIG.BACKUP_DIR)) {
            fs.mkdirSync(CONFIG.BACKUP_DIR, { recursive: true });
            const backupPath = path.join(CONFIG.BACKUP_DIR, `${ruleData.name}.json.bak`);
            fs.copyFileSync(filePath, backupPath);
          }
          
          fs.writeFileSync(filePath, JSON.stringify(ruleData, null, 2));
          console.log(`  âœ… å·²ä¿å­˜ ${ruleData.name}.json`);
        }
        
        // å¹¶å‘æ§åˆ¶
        async function processRulesInBatches(rules, processor) {
          const results = [];
          for (let i = 0; i < rules.length; i += CONFIG.MAX_CONCURRENT) {
            const batch = rules.slice(i, i + CONFIG.MAX_CONCURRENT);
            const batchResults = await Promise.allSettled(
              batch.map(processor)
            );
            results.push(...batchResults);
          }
          return results;
        }
        
        // ä¸»åŒæ­¥é€»è¾‘
        async function syncRules() {
          try {
            console.log('ğŸš€ å¼€å§‹åŒæ­¥ KazumiRules...');
            console.log(`ğŸ“‹ åŒæ­¥ç­–ç•¥: ${CONFIG.SYNC_STRATEGY}`);
            
            // ç¡®ä¿ç›®å½•å­˜åœ¨
            if (!fs.existsSync(CONFIG.LOCAL_RULES_DIR)) {
              fs.mkdirSync(CONFIG.LOCAL_RULES_DIR, { recursive: true });
            }
            
            // è·å–è¿œç¨‹å’Œæœ¬åœ°ç´¢å¼•
            const remoteIndex = await fetchKazumiIndex();
            const localIndex = getLocalIndex();
            
            console.log(`ğŸ“Š è¿œç¨‹è§„åˆ™æ•°é‡: ${remoteIndex.length}`);
            console.log(`ğŸ“Š æœ¬åœ°è§„åˆ™æ•°é‡: ${localIndex.length}`);
            
            // åˆ›å»ºæœ¬åœ°è§„åˆ™æ˜ å°„
            const localRulesMap = {};
            localIndex.forEach(rule => {
              localRulesMap[rule.name] = rule;
            });
            
            // ç­›é€‰éœ€è¦å¤„ç†çš„è§„åˆ™
            let rulesToProcess = remoteIndex;
            
            if (CONFIG.SYNC_STRATEGY === 'selective' && CONFIG.SELECTED_RULES.length > 0) {
              rulesToProcess = remoteIndex.filter(rule => CONFIG.SELECTED_RULES.includes(rule.name));
              console.log(`ğŸ¯ é€‰æ‹©æ€§åŒæ­¥è§„åˆ™: ${CONFIG.SELECTED_RULES.join(', ')}`);
            }
            
            stats.total = rulesToProcess.length;
            
            // å¤„ç†æ¯ä¸ªè§„åˆ™
            const results = await processRulesInBatches(rulesToProcess, async (remoteRule) => {
              const localRule = localRulesMap[remoteRule.name];
              
              if (!shouldUpdateRule(remoteRule, localRule)) {
                console.log(`  â­ï¸  è·³è¿‡ ${remoteRule.name} (æ— éœ€æ›´æ–°)`);
                stats.skipped++;
                return { status: 'skipped', rule: remoteRule };
              }
              
              try {
                const ruleData = await downloadRule(remoteRule.name);
                saveRule(ruleData);
                
                stats.downloaded++;
                if (localRule) {
                  stats.updated++;
                  console.log(`  ğŸ”„ å·²æ›´æ–° ${remoteRule.name} (${localRule.version} â†’ ${remoteRule.version})`);
                } else {
                  stats.added++;
                  console.log(`  â• å·²æ·»åŠ  ${remoteRule.name} (${remoteRule.version})`);
                }
                
                return { status: 'success', rule: remoteRule };
              } catch (error) {
                stats.failed++;
                console.error(`  âŒ å¤„ç† ${remoteRule.name} å¤±è´¥: ${error.message}`);
                return { status: 'failed', rule: remoteRule, error };
              }
            });
            
            // è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
            console.log('\nğŸ“Š åŒæ­¥ç»Ÿè®¡:');
            console.log(`  æ€»è®¡: ${stats.total}`);
            console.log(`  ä¸‹è½½: ${stats.downloaded}`);
            console.log(`  æ›´æ–°: ${stats.updated}`);
            console.log(`  æ–°å¢: ${stats.added}`);
            console.log(`  è·³è¿‡: ${stats.skipped}`);
            console.log(`  å¤±è´¥: ${stats.failed}`);
            
            if (stats.errors.length > 0) {
              console.log('\nâŒ é”™è¯¯è¯¦æƒ…:');
              stats.errors.forEach(error => console.log(`  - ${error}`));
            }
            
            // è®¾ç½® GitHub Actions è¾“å‡º
            const output = {
              total: stats.total,
              downloaded: stats.downloaded,
              updated: stats.updated,
              added: stats.added,
              skipped: stats.skipped,
              failed: stats.failed,
              has_changes: stats.downloaded > 0
            };
            
            // è®¾ç½® GitHub Actions è¾“å‡º (æ–°æ ¼å¼)
            if (process.env.GITHUB_OUTPUT) {
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `sync_stats=${JSON.stringify(output)}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `has_changes=${output.has_changes}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `total=${output.total}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `downloaded=${output.downloaded}\n`);
            }
            
            // å†™å…¥åŒæ­¥ç»“æœæ–‡ä»¶ç”¨äºè°ƒè¯•
            const resultSummary = {
              strategy: CONFIG.SYNC_STRATEGY,
              timestamp: new Date().toISOString(),
              stats: stats,
              has_changes: stats.downloaded > 0
            };
            
            fs.writeFileSync('sync_result.txt', JSON.stringify(resultSummary, null, 2));
            
            if (stats.downloaded > 0) {
              console.log('\nâœ… åŒæ­¥å®Œæˆï¼Œæœ‰æ–‡ä»¶æ›´æ–°');
            } else {
              console.log('\nâœ… åŒæ­¥å®Œæˆï¼Œæ— æ–‡ä»¶æ›´æ–°');
            }
            
          } catch (error) {
            console.error('âŒ åŒæ­¥å¤±è´¥:', error.message);
            process.exit(1);
          }
        }
        
        // æ‰§è¡ŒåŒæ­¥
        syncRules();
        EOF
        
    - name: æ‰§è¡ŒåŒæ­¥
      id: sync
      env:
        SYNC_STRATEGY: ${{ github.event.inputs.sync_strategy || 'smart' }}
        SELECTED_RULES: ${{ github.event.inputs.selected_rules || '' }}
        FORCE_UPDATE: ${{ github.event.inputs.force_update || 'false' }}
      run: node sync_kazumi_rules.js
      
    - name: æ£€æŸ¥åŒæ­¥ç»“æœ
      id: check-sync
      run: |
        # æ£€æŸ¥ rules ç›®å½•æ˜¯å¦å­˜åœ¨ä¸”æœ‰ JSON æ–‡ä»¶
        if [ -d "./rules" ] && [ "$(find ./rules -name '*.json' | wc -l)" -gt 0 ]; then
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "files_count=$(find ./rules -name '*.json' | wc -l)" >> $GITHUB_OUTPUT
          echo "âœ… å‘ç° $(find ./rules -name '*.json' | wc -l) ä¸ªè§„åˆ™æ–‡ä»¶"
        else
          echo "has_changes=false" >> $GITHUB_OUTPUT  
          echo "files_count=0" >> $GITHUB_OUTPUT
          echo "â„¹ï¸  æœªå‘ç°è§„åˆ™æ–‡ä»¶"
        fi
        
        # é¢å¤–æ£€æŸ¥ï¼šè¾“å‡ºåŒæ­¥è„šæœ¬çš„ç»“æœ
        if [ -f "sync_result.txt" ]; then
          echo "ğŸ“Š åŒæ­¥è„šæœ¬ç»“æœ:"
          cat sync_result.txt
        fi
        
    - name: æ›´æ–°æœ¬åœ° index.json
      if: steps.check-sync.outputs.has_changes == 'true'
      run: |
        # å¤ç”¨ç°æœ‰çš„åŒæ­¥è„šæœ¬é€»è¾‘
        cat > update_index.js << 'EOF'
        const fs = require('fs');
        const path = require('path');
        
        const rulesDir = './rules';
        const indexFile = './index.json';
        
        let existingIndex = [];
        if (fs.existsSync(indexFile)) {
          try {
            existingIndex = JSON.parse(fs.readFileSync(indexFile, 'utf8'));
          } catch (error) {
            console.log('æ— æ³•è¯»å–ç°æœ‰index.jsonï¼Œå°†åˆ›å»ºæ–°çš„');
          }
        }
        
        const ruleFiles = fs.readdirSync(rulesDir)
          .filter(file => file.endsWith('.json'));
        
        const indexData = [];
        
        ruleFiles.forEach(file => {
          try {
            const filePath = path.join(rulesDir, file);
            const ruleData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            const ruleName = ruleData.name || path.basename(file, '.json');
            
            const existingRule = existingIndex.find(rule => rule.name === ruleName);
            const fileStats = fs.statSync(filePath);
            const fileModTime = fileStats.mtime.getTime();
            
            let lastUpdate;
            if (existingRule) {
              if (fileModTime > existingRule.lastUpdate) {
                lastUpdate = Date.now();
                console.log(`è§„åˆ™ ${ruleName} å·²æ›´æ–°`);
              } else {
                lastUpdate = existingRule.lastUpdate;
              }
            } else {
              lastUpdate = Date.now();
              console.log(`æ–°è§„åˆ™ ${ruleName} å·²æ·»åŠ `);
            }
            
            const indexEntry = {
              name: ruleName,
              displayName: ruleData.displayName || ruleName,
              version: ruleData.version || "1.0",
              useNativePlayer: ruleData.useNativePlayer !== false,
              author: ruleData.author || "",
              lastUpdate: lastUpdate
            };
            
            indexData.push(indexEntry);
          } catch (error) {
            console.error(`å¤„ç†æ–‡ä»¶ ${file} æ—¶å‡ºé”™:`, error.message);
          }
        });
        
        indexData.sort((a, b) => a.name.localeCompare(b.name));
        
        fs.writeFileSync(indexFile, JSON.stringify(indexData, null, 2));
        console.log(`å·²åŒæ­¥ ${indexData.length} ä¸ªè§„åˆ™åˆ° index.json`);
        EOF
        
        node update_index.js
        
    - name: æäº¤å˜æ›´
      if: steps.check-sync.outputs.has_changes == 'true'
      run: |
        git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add rules/ index.json
        
        # ç”Ÿæˆæäº¤ä¿¡æ¯
        COMMIT_MSG="ğŸ”„ åŒæ­¥ KazumiRules è§„åˆ™æ–‡ä»¶
        
        - åŒæ­¥ç­–ç•¥: ${{ github.event.inputs.sync_strategy || 'smart' }}
        - è§„åˆ™æ–‡ä»¶æ•°: ${{ steps.check-sync.outputs.files_count }}
        - è§¦å‘æ–¹å¼: ${{ github.event_name }}
        
        [skip ci]"
        
        git commit -m "$COMMIT_MSG"
        git push
        
    - name: åŒæ­¥å®Œæˆé€šçŸ¥
      if: always()
      run: |
        echo "ğŸ“Š åŒæ­¥ç»Ÿè®¡ä¿¡æ¯:"
        echo "  - æ£€æŸ¥ç»“æœ: has_changes=${{ steps.check-sync.outputs.has_changes }}"
        echo "  - æ–‡ä»¶æ•°é‡: files_count=${{ steps.check-sync.outputs.files_count }}"
        
        if [ "${{ steps.check-sync.outputs.has_changes }}" == "true" ]; then
          echo "âœ… KazumiRules åŒæ­¥å®Œæˆï¼"
          echo "ğŸ“ å·²åŒæ­¥ ${{ steps.check-sync.outputs.files_count }} ä¸ªè§„åˆ™æ–‡ä»¶"
          echo "ğŸ”„ æœ¬åœ° index.json å·²è‡ªåŠ¨æ›´æ–°"
        else
          echo "â„¹ï¸  æ— éœ€åŒæ­¥ï¼Œæ‰€æœ‰è§„åˆ™éƒ½æ˜¯æœ€æ–°çš„"
          echo "ğŸ” è°ƒè¯•ä¿¡æ¯: æ£€æŸ¥ rules/ ç›®å½•æ˜¯å¦å­˜åœ¨æ–‡ä»¶"
          ls -la rules/ || echo "rules/ ç›®å½•ä¸å­˜åœ¨æˆ–ä¸ºç©º"
        fi
